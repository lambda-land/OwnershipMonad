\documentclass[onehalf,11pt]{beavtex}
\title{The Ownership Monad}
\author{Michael McGirr}
\degree{Master of Science}
\doctype{Thesis}
\department{Electrical Engineering and Computer Science}
\depttype{School}
\depthead{Director}
\major{Computer Science}
\advisor{Eric Walkingshaw}
\submitdate{TODO submit date}
\commencementyear{TODO commencement year}
\abstract{TODO abstract statement.}
\acknowledgements{TODO}

\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{hyperref} % For links

\begin{document}
\maketitle

\mainmatter

\chapter{Introduction}

This project report presents a library for Haskell that implements an
\textit{ownership system} for resource aware programming. This ownership system
introduces a set of rules that govern how, when, and by whom a resource within
what is called an \textit{Owned Reference} (an \texttt{ORef}) can be used.

While the restrictions this implementation imposes may seem to increase the
complexity of writing programs, the resulting guarantees offer improvements in
specific areas.
Furthermore applying this system provides an example for how monadic based
approaches can offer abilities to reason about resource usage.

Adding a way to keep track of resources in a pure language like Haskell may
at the onset seem unnecessary since in a pure language, by definition,
the data making up the resources bound to variables is immutable.
% TODO Add citation
Because of this there is no inherent state.  Haskell's purity therefore allows
for referential transparency where values and variables in closed expressions
can be thought of as being interchangeable.
% Evaluating an expression using the same inputs will result in the same output.

Referential transparency is a desirable property which allows for a greater
ability to reason about the behavior and correctness of a program.
Even in a pure language like Haskell, this property breaks down in the context
of concurrency.  In order to allow separate threads to communicate the basic
mechanisms provided by Concurrent Haskell introduce mutable state.
Adding mutable state and sharing it between threads explicitly introduces
side-effects into otherwise pure and referentially transparent computations.
Under these circumstances, Haskell's usual approach of segregating side-effects
into monadic computations does not resolve every issue that can exist with
shared-state concurrency.

For example a race condition can be created when a mutable reference is shared
across a channel between two threads:

\begin{verbatim}
import Data.IORef
import Control.Concurrent
import Data.Char (toLower, toUpper)

main :: IO ()
main = do
  ref <- newIORef "test"
  ch <- newChan
  writeChan ch ref

  _ <- forkIO $ do
    ref' <- readChan ch
    modifyIORef ref' (map toLower)

  val <- readIORef ref
  putStrLn val

  modifyIORef ref (map toUpper)
  val <- readIORef ref
  putStrLn val
\end{verbatim}

Here the \texttt{forkIO} function takes an expression of type \texttt{IO ()}
and executes it in a new thread.
% It returns the thread ID of the new child thread but this is discarded with an
% underscore \texttt{_}.
This new thread will run concurrently with the original parent thread.

This creates a clear race condition between the two threads and the mutable
contents of the \texttt{IORef} shared between them. Both threads have access
to the same \texttt{IORef} and it could be unclear which will access the
resource first. Under these conditions the issue is not only that we have
shared mutable state but that we have shared access to that state.

Immutable data structures simplify concurrency and are preferable to
mutable structures. However categories of problems still exist where a
mutable structure is required.

Linear types are often suggested as a possible solution to limit the issues that
result from mutable state \cite{Wadler90lineartypes} and concurrency
\cite{caires2010session}.  Language level support for linear types has been
proposed for the Glasgow Haskell Compiler. \cite{LinearTypesGHC}
% This would add plain linear types, directly inspired from linear logic.
Ways to add linear types to Haskell without language level support have also
been demonstrated using embedded domain specific languages within a monadic
context. \cite{Paykin:2017:LM:3122955.3122965}

Other less restrictive forms of logic have been used in type systems for similar
resource tracking.
Affine type systems weaken the restrictions imposed by linear type systems.
Instead of requiring every variable to be used exactly once - as is the case
with linear types - every variable must be used at most once.
The language level Ownership typing in Rust has been directly inspired by Affine
type systems. % TODO Add more here/ rework this sentence

\section{Contributions}

This project draws from the use of affine types in Rust for
ownership typing to define a similar method for tracking resources with Haskell.
This is combined with the approach of defining embedded languages in monadic
programming to allow for dynamic ownership checking without language level
support for affine types in Haskell.
% This project will demonstrate that the existing model
% for embedded languages in monadic programming extends to affine types.

Concurrent Haskell programs can still fall prey to some of the same fundamental
problems that other impure languages can, namely deadlock and starvation.
% TODO add citation for shared-state concurrency from Real World Haskell
% In Concurrent Haskell the most basic way to allow separate threads to
% communicate is with a shared mutable variable. 
This project report will demonstrate a motivation for adding the kind of
resource tracking that ownership typing provides by looking at what some of
these problems look like and how resource tracking acts to mitigate these
problems.  This will use the basic concurrency tools available in Haskell
such as shared state with MVar's and message passing with Channels.
It will then demonstrate and explain the benefits of tracking resource usage
with a set of rules similar to affine types.


% While this library does not do so - by tracking resources with the ownership
% system it becomes in theory possible to reason about the memory usage over the
% lifetime of a program using the type system of the language. 
% refer to:
%https://groups.google.com/d/msg/idris-lang/NsxReBzk7LQ/0fSPgu-4EgAJ
% This method makes it possible to do a form of automatic deterministic destruction
% instead of the typical garbage collection approaches.  This paper will show
% where in an example program this could occur.

% TODO refer to this:
% Using the type system to encode and explain what is happening with the underlying
% resources in a general way that can be independently verified and checked greatly
% increases our confidence and ability to know when a resource is finished being used.
% refer to Edwin Brady quote at:
% https://groups.google.com/d/msg/idris-lang/Z28F3MBBtTM/XOnUcrvsBAAJ


\chapter{The Ownership Monad}

The term \textit{Ownership System} is used to describe the system for how
resources are tracked and how they can be used once they are created. This
system operates within the context of the ownership monad.
The ownership system this library implements is inspired by
ownership typing in Rust as well as Uniqueness Types
from Idris.\cite{rust_book_ownership} \cite{idris_uniqueness_types}
% Restricting all entities to following the rules specified under an
% affine typing system discipline is applied under the ownership typing system in
% the Rust programming language. % TODO rework
The ownership system described by this paper approximates some of the
features from ownership typing in the Rust language. Differences between
the two result from the different language paradigms and the different use
cases.

Uniqueness types in Idris, ownership typing in Rust, and the ownership system
make use of the idea that by tracking resource use and applying rules to how
resources are used - certain properties can be enforced.
% TODO Such as? Briefly what these are here

\section{Implementation}

The type of the ownership monad:

\begin{verbatim}
type Own a = StateT (ID,Store) (EitherT String IO) a
\end{verbatim}

% TODO explain EitherT as well as IO

State is represented using the \texttt{StateT} monad transformer.
The ownership monad needs to track the state of ownership system operations
that occur within its context but it does not need to be aware of the
operations occurring in other ownership monads.
This latter aspect will become important when discussing Owned Channels between
separate threads later on.

The state in the ownership monad is comprised of the next \texttt{ID}
to use and the current \texttt{Store}.  The \texttt{Store} maps each unique
reference \texttt{ID} to an \texttt{Entry}.

\begin{verbatim}
data Entry =
  forall v. Typeable v => Entry Flag ThreadId (Maybe (IORef v))
\end{verbatim}

The first notable parts of the \texttt{Entry} datatype are the explicitly
quantified \texttt{forall v} along with the \texttt{Typeable} typeclass
constraint on the type variable \texttt{v}.
The combination of these allows for the references in the state to be
heterogeneous.
Otherwise it would be necessary to limit the \texttt{Store} to owned
references of only one type per monadic state. % Right?
Using the \texttt{Typeable} typeclass does require that values in each entry are
\texttt{cast} in a type-cast operation.  However this is handled internally
by the library when values are retrieved from an entry.
The \texttt{cast} function reifies the generic type \texttt{v} into a real
type.
Doing so is necessary because it allows the value inside an entry to be used
as a concrete type rather than a polymorphic value.

Using the existentially quantified \texttt{forall v} also provides the
ancillary benefit that the \texttt{Entry} datatype does not need a type
variable.
As a result, the \texttt{Store} type does not need to be a parameterized abstract
data type and can instead be a simple mapping between an integer ID and an entry.

\begin{verbatim}
type Store = IntMap Entry
\end{verbatim}

Each owned reference \texttt{Entry} maintains a \texttt{Flag} to indicate the
level of access currently allowed by the ownership monad on the entry's value.
% TODO explain what each of these are.

\begin{verbatim}
data Flag = Locked
          | Readable
          | Writable
\end{verbatim}

The ID of the thread which owns the entry is also stored as part of the
\texttt{Entry} datatype. 

The value \texttt{v} in an \texttt{Entry} is maintained within the
\texttt{(Maybe (IORef v))} field of the entry datatype.
The main purpose of using the \texttt{Maybe} datatype is it allows an empty entry
to be represented.
Empty entries are created when entries are dropped from one ownership monad's
context.  This allows the Glasgow Haskell Compiler to know that
the runtime memory storing the prior value in an entry can be freed.

Internally the value stored in a non-empty entry is placed in an \texttt{IORef}.
An \texttt{IORef} in Haskell is a mutable reference in the IO monad - an IO
reference.
The ownership monad uses entries to store the values assigned to owned
references.
Even though the values in entries are mutable because of the internal \texttt{IORef}
implementation, they are encased in the ownership system types which control
access to the value.
One of the primary motivations for using the ownership monad by itself is as a
safer way to introduce mutability, when it is needed, into a Haskell program.
This will be discussed later on when talking about operations for working with
owned references and using the ownership monad.


\section{The Ownership System}

Apart from ownership monad type \texttt{Own}, the internal data structures
discussed so far have been part of the implementation and would be invisible to
the user of the library.
From the perspective of the library user: owned references are abstract
data types defined by the operations which can act on references in the
ownership monad.
The semantics of how owned references exist and operate correspond to the
outcomes of using these operations.
The functions to perform operations are made available in the public facing API
module of the library for this implementation.

\subsection{Owned References}

Owned references represent variables which provide both the symbolic entity
which owns a resources as well as the mechanism to access the underlying resource.
Resources are bound to a variable when they are created inside the ownership
monad. In the library implementation these variables are called ORef's or
\textit{Owned References}.

The type of an \texttt{ORef} is a thin wrapper around a way to tag and identify
resources stored in entries.

\begin{verbatim}
newtype ORef a = ORef {getID :: ID}
\end{verbatim}

An \texttt{ORef} is a parameterized abstract data type. Because there is only
one constructor and one field associated with this datatype it is possible to
use newtype to eliminate some of the runtime overhead.

A phantom type is used to add a type variable to each \texttt{ORef}. This
increases the type safety of the code by requiring that a type be embedded
with each \texttt{ORef}.
This prevents references of different types from being mixed by invoking a
type error at compile time.
The polymorphic \texttt{a} allows any type to be stored in an \texttt{ORef}.
This \texttt{ORef} datatype primarily serves to provide a handle on each
resource for the ownership monad to use as it enforces ownership typing rules
and tracks each resource.

When the operations inside an ownership monad are complete the references
will no longer exist and the resources associated with each one will be marked
as free.
% TODO this is actually quite significant and worth explaining more because it
% allows us to determine when a resource no longer needs to exist.
% (can be automatically destroy and freed)
% Explain that ORef's are dropped once the monad is finished evaluating - and we
% know they can be dropped then.
The information inside the resource can only be accessed by the provided
operations for references within the ownership monad.
The operations which act on owned references will verify whether the ownership
rules are being followed and detect violations.

Operations create owned references, copy them, move the resource from one
reference to another, drop a reference from the scope, and write a value to a
reference.
Additionally there are operations for borrowing the resource inside a reference.
Borrowing allows a function to temporarily use the resource without taking
ownership over it.

\subsection{Reference Creation}

The \texttt{newORef} function creates a new owned reference
within the ownership monad and places the value provided to the function
inside the reference. This value is internally stored within an \texttt{IORef}
in the \texttt{Entry} datatype.

\begin{verbatim}
newORef :: Typeable a => a -> Own (ORef a)
newORef a = do
    (new, store) <- get
    thrId <- liftIO $ myThreadId
    v <- liftIO $ newIORef a
    let entry = (Entry Writable thrId (Just v))
    put (new + 1, insert new entry store)
    return (ORef new)
\end{verbatim}

The current state of the monad is needed in order to produce the next state
which will include the new owned reference.
The new owned reference is a mapping of an ID and the entry. The entry
contains the value being stored as well as the state of the owned reference.
Performing \texttt{get} will return the ID to use next as well as the current
mapping of owned reference ID's and their entries.

The thread ID of the thread which created the owned reference must
be stored.  This is done in order to prevent child threads from using the owned
references that were potentially inherited through the name-spacing scope of
their parent threads.  The thread ID field of and entry is set when the owned
reference is initially created. This requires an \texttt{IO} operation to be
performed in order to get the current thread ID of the thread creating the
new \texttt{ORef}.

The entry that will be inserted into the new mapping will have a \texttt{Flag}
which is set to \texttt{Writable}.
The new store of entries, as well as the incremented ID, are put back into the
state.
The final step is to return the new \textit{ORef} so that it can be used by other
ownership operations.
% Resources that are put into references can only have one owner at any given
% time. The reference bound to the newly initialized resource becomes the sole
% owner of that resource. 

\subsection{Dropping an Owned Reference}

The \textit{drop} operation will explicitly remove an owned reference from the
ownership monad it previously existed in.
This will destroy the resource from the point of view of the other operations
in that ownership context.

\begin{verbatim}
dropORef :: Typeable a => ORef a -> Own ()
dropORef oref = do
    ok <- checkORef oref
    case ok of
      False -> lift $
        left "Error during drop operation.\
             \ Make sure ORef intended to be dropped is writable\
             \ and within this thread."
      True -> do
        setORefLocked oref
        setValueEmpty oref
\end{verbatim}

Any further operations that try to use the dropped reference will be prevented
from occurring.
The reference must be in the same thread as the drop operation and the owned
reference must have a \texttt{Writable} flag. These two conditions are checked
by the \texttt{checkORef} helper function.

\begin{verbatim}
checkORef :: ORef a -> Own Bool
checkORef oref  = do
  entry@(Entry _f thrId _v) <- getEntry oref
  liftIO $ do
    threadId <- myThreadId
    return $ (threadId == thrId) && writable entry
\end{verbatim}

If the ownership system rules are not being violated then the ORef will be
dropped by having it's flag set to \texttt{Locked} and the value in the
entry set to \texttt{Nothing}. The entry is not deleted from the mapping of
ID's to entries. Doing so allows the ownership system to determine if an ORef
has been dropped or if it never existed.
The resource space inside the entry of a dropped reference can be freed since
the Haskell runtime will garbage collect the previous value that has now been
set to the \texttt{Nothing} case.

\subsection{Copying a Reference}

The underlying resource owned by a reference may be copied by other references
if they are within the scope of the same ownership monad.  When this occurs a new
reference is created and then given ownership over a copy of the resource.
After a copy operation is performed the two references will each own what are now,
essentially, two separate and different resources.

\begin{verbatim}
copyORef :: ORef a -> Own (ORef a)
copyORef oref = do
    (new, store) <- get
    entry <- getEntry oref
    ok <- inThreadAndReadable oref
    case ok of
      False -> lift $ left "Error during copy operation"
      True -> do
        let newEntry = setEntryWritable entry
        put (new + 1, insert new newEntry store)
        return (ORef new)
\end{verbatim}

The \texttt{copyORef} operation checks for an ownership system violation when
it is run.
A copy can be made if the underlying owned reference is at least readable and
is in the same thread as the copy operation.
To perform a thread ID check the \texttt{inThreadAndReadable} function
needs to be lifted from the \texttt{IO} monad.
The \texttt{inThreadAndReadable} function will return true if the owned reference
is at least readable and in the same thread.

\begin{verbatim}
inThreadAndReadable :: ORef a-> Own Bool
inThreadAndReadable oref = do
  entry@(Entry _f thrId _v) <- getEntry oref
  liftIO $ do
    threadId <- myThreadId
    return $ (threadId == thrId) && readable entry
\end{verbatim}

An owned reference which is set to readable signals that there may be other
operations using the resource in a way that is immutable.
If an ORef is writable this indicates that no function is currently using the
resource in a way that may mutate the value.

If the copy operation is able to occur the new owned reference is inserted into
the store for that monad.  The new owned reference created from the copy
operation is set as writable. The \texttt{setEntryWritable} function
creates a duplicate entry with its flag set to writable.
This action is performed even if the original reference was only
readable.

% Move to related work?
For those familiar with the terminology from the Rust programming language, the
term \textit{copy} here is not the same as a copy in Rust. Rust makes a special
distinction between making a copy of resources that are fixed in size
\footnote{Rust will also consider an assignment operation to be a copy instead
  of a move if the \textbf{Copy} trait or the \textbf{Clone} trait is
  implemented for that type of resource. \cite{rust_book_traits}
  \cite{rust_docs_clone_trait}}
and making a copy of resources which are more complex and not fixed in size.
For the latter case it is still possible to copy these kinds of resources but these
need to be cloned (using the clone function) otherwise Rust will consider these
values to have been moved. \cite{rust_book_ownership}
With this library there is only one version of a copy and it creates a new
resource identical to the original; there is no distinction given to the kinds
of resources that are being copied.

\subsection{Moving Ownership}

A resource owned by a reference can also be transferred to a new reference or
to an existing reference. After this operation is performed it will no longer
be possible to refer to the underlying resource through the old reference. This
operation removes the old reference from the scope of the ownership monad it
previously existed in and the new reference is now the sole owner of the
resource.

\begin{verbatim}
moveORef :: Typeable a => ORef a -> Own (ORef a)
moveORef oldORef = do
    ok <- checkORef oldORef
    case ok of
      False -> lift $
        left "Error during move from an oref to a new oref\
             \ check entry failed for the existing (old) oref."
      True -> do
        new <- copyORef oldORef
        dropORef oldORef
        return new
\end{verbatim}

The implementation of \texttt{moveORef} verifies that the old ORef is writable.
The old ORef must also exist within the same thread as the ownership monad in
which the operations are being performed in.

The ownership system needs to enforce that the old ORef is
writable in order for this operation to occur because this indicates that the
resource has not been dropped and is still valid to use in this context.
The ORef must also be writable in order to ensure that another function
is not currently borrowing the resource in a mutable way.

If the old ORef is valid and can be used in the operation a copy of it is made
with the \texttt{copyORef} function.  After the copy is complete the old ORef
is dropped using the \texttt{dropORef} function. This removes the old ORef from
that monad and prevents other operations from referring to the resource through
the old ORef.
The old ORef and its entry have been dropped and are set to \texttt{Nothing}.
The resource space inside the entry corresponding to the old ORef can be safely
freed.

There is a key difference between moving a resource from an existing reference
and copying it to a new one.  Functionally a resource that is copied is cloned
and duplicated; doing this doubles the space and creates a new resource.
A moved resource by comparison doesn't change.  Instead what is altered is the
record of who owns that resource.  Neither operation, moving and copying,
creates a situation where more than one reference owns a resource.

\subsection{Writing to a Resource}

A resource can be changed by its owner as long as it is writable.
The value within the resource can be updated and changed through the reference
that owns the resource. This operation can be performed safely because the usage
of the underlying resource is tracked by the ownership monad.

\begin{verbatim}
writeORef :: Typeable a => ORef a -> a -> Own ()
writeORef oref a = do
    ok <- checkORef oref
    case ok of
      False -> lift $
        left "Error during write operation. Checking if the entry\
             \ could be written to or if it was in the same thread\
             \ returned False."
      True -> setValue oref a
\end{verbatim}

The reference that is being changed cannot have any functions using the
\texttt{ORef} and it must be in the same thread as the write operation.
When the operation is performed the existing resource inside the ORef is over
written by the new value.

\subsection{Borrowing a Resource}

Borrowing a resource is the operation that allows a function to be able to use
the contents of an owned reference.
A resource can be used within the confines of the ownership monad by its owner
and a function. This function will be required to remain in the
context of the original ownership monad.

% TODO move to related works section
This operation is similar to passing a value to a function as a mutable
borrow in the Rust language.
To give some background on what this means:
depending on the type signature a function in Rust will either copy the value
it is passed, take ownership of the value, or it will borrow the value - in
which case ownership of the value is automatically returned when the function
has finished execution.\cite{rust_book_ownership}
A function in Rust that takes a borrowed value as an argument is - in a way -
syntactic sugar over that function first taking ownership of the value and then
returning ownership over the value by placing it within the expression that is
returned.
Instead of having to do these steps explicitly a value can be passed to a
function as a borrowed value.  When a value is borrowed, the function will take
a reference to that the value from the original owner and eventually the
ownership of the resource will be handed back when the function returns.
The Rust compiler which will track the borrows (with the borrow checker).
% TODO add citation

Borrows in Rust come in two flavors - we can either lend a resource to many
borrowers as long as the borrowers never mutate the underlying resource - or we
can lend it to a single borrower that will be able to mutate the
resource.\cite{rust_book_borrowing}
It should be clear why giving multiple variables mutable access to
the same resource could create data races which is why mutable borrows to
multiple variables (or functions) are not allowed.

This library takes a slightly different approach: instead of letting variables
borrow a resource, a borrow operation instead lends the resource to a function
which temporarily borrows the resource in order to use it and potentially mutate
it in place.

\begin{verbatim}
borrowORef :: Typeable a => ORef a -> (a -> Own b) -> Own b
borrowORef oref k = do
    ok <- checkORef oref
    case ok of
      False -> lift $
        left "Error during borrow operation.\
             \ The checks for if the entry was in the same thread\
             \ as the borrow operation and if the entry could be written to\
             \ returned false."
      True -> do
        setORefLocked oref
        v <- getValue oref
        b <- k v
        setORefWritable oref
        return b
\end{verbatim}

A borrow operation can occur if the owned reference is writable and
in the same thread as the operation.
While the resource is being borrowed it is prevented from being written to or
read by other operations. The \texttt{setORefLocked} function adjusts the flag
on the entry inside a owned reference to locked.

The function that is passed in a borrow can regard the value it sees as the
current state of the resource in the \texttt{ORef}. This differs from reading a
reference and making a copy of its value which will be discussed next.

The value inside a reference uses the internal library function
\texttt{getValue}. This will raise an error condition if an
attempt is made to get an empty \texttt{Nothing} value.

\begin{verbatim}
getValue :: Typeable a => ORef a -> Own a
getValue oref = do
  e <- getEntry oref
  v <- liftIO (value e)
  case v of
    Just a -> return a
    Nothing -> lift $ left "Cannot retrieve the value of an empty ORef"
\end{verbatim}

The internal \texttt{value} function is responsible for reading a value from
the \texttt{IOREf} it is stored in and reifing it to a concrete type.
This function handles the failure conditions that could come
about from casting the value inside an entry to a concrete type.

\begin{verbatim}
value :: Typeable a => Entry -> IO (Maybe a)
value (Entry _ _ (Just ioref)) = do
  v <- readIORef ioref
  case cast v of
    Just a  -> return (Just a)
    Nothing -> error "internal cast error"
value (Entry _ _ Nothing) = return Nothing
\end{verbatim}

The function that borrows the resource is of type \texttt{(a -> Own b)}. The
resource being consumed in the function remains inside of the context of the
ownership monad while the function executes. % TODO explain why this matters

Much like the Rust language will not allow for a mutable resource to be lent to
multiple borrowers - neither will the borrow operation on an \texttt{ORef}.
This will ensure that the resource is not mutated or written to while is it lent
out to the borrowing function.
Because each borrow operation occurs within the context of the ownership monad
the resource usage can be tracked and this property can be ensured. The
reference that owns the resource will track the resource while the function
executes.

The borrow operation also ensures that the original \texttt{ORef} does not
go away before the function borrowing it is complete. This will make sure that
the function is not referring to an \texttt{ORef} that no longer exists.
The \texttt{ORef} that is being borrowed by the function is not able to be moved
(or otherwise dropped) before the function that the resource has been lent to is
complete. This is enforced by the move and drop operations which individually
check that a \texttt{ORef} does not have any functions borrowing the resource.

This library does not allow multiple functions to simultaneously perform
\textit{borrow} operations on an existing \texttt{ORef}.
This restrictions means that the borrowing function is assumed to mutate the
value in the reference but it is not required to do so.

% There is no equivalent to a variable being borrowed by more than one immutable
% borrower in Rust.
% This could be done by making multiple copies of an \texttt{ORef} and
% then giving these to individual borrowers.


% TODO this seems to be redundant and okay to get rid of.
% To allow a mutable borrow it is necessary to know if other functions are
% borrowing the resource. A mutable borrow can only occur if the reference
% is readable and writable.
% Each \texttt{ORef} already tracks if it is able to be read from or written to.

% To allow for a borrower to have mutable access to the reference it needs to be
% the sole borrower. If a resource can be both read from and written to then we
% know it doesn't have any borrowers.


% TODO explain why a mutableBorrowORef is not the same as a writeORef

% TODO mention the other variant of borrows (named borrowORef')?

\subsection{Reading from an ORef}

A read operation is slightly different than a borrow operation. Where a borrow
operation gives a function exclusive and monitored access to a resource, a read
operation will take a snapshot of the current contents. The snapshot is returned
but no guarantees can be made about the current contents of the \texttt{ORef}
after the read operation has completed.

Reading from an \texttt{ORef} will reveal what the contents of the \texttt{ORef}
was at the time the read was performed.  The \texttt{ORef} will continue to
exist after the read operation and the value inside it may change.
The advantage of using a read instead of a borrow is that it removes a copy of
the resource from the \texttt{ORef}. This copy is freed from the restrictions
imposed by the ownership system.

\begin{verbatim}
readORef :: Typeable a => ORef a -> Own a
readORef oref = borrowORef oref return
\end{verbatim}


% \section{ORef's}

% TODO ORef's example section


\chapter{Owned Channels}

\section{Introduction}

\textit{Owned Channels} expand on the concept of using channels between threads
to write to and read from a shared location.   As with traditional Channels,
this location can be used by concurrent threads in order to share resources and
to communicate.

% Shared state brings with it all the dangers associated with it. REWORK
% As our example shows - issues can crop up when resources are shared between
% threads. % TODO add example

Owned channels operate using the idea that instead of sending just the
resource across a channel - send the ownership of the resource as well.
The key idea behind owned channels is for the thread sending a
resource across a channel to relinquish ownership over the resource.
A thread reading a resource from the channel automatically gains ownership over
the resource it consumes from the channel.

Once a thread has sent a resource over the channel - all operations in the thread
will need to be prevented from using that resource.
If the thread later needed to use the resource again it would have to read the
resource from a channel and gain back ownership over the resource.

Traditionally the variable that was written to a channel would still exist in the
scope of the code in the thread that originally wrote the resource to a channel.
As a result it would be perfectly legal to write code that later referred to the
resource through an existing variable binding in the original thread.
% TODO refer to a code example for this
In order to enforce which thread owns which resource, there would need to be
some way to track not just what a resource is but also what variable (and what
thread) owns a resource.

\subsection{Using Owned References to Construct Owned Channels}

As discussed earlier, owned references provide a fundamental set of
rules generalizing resource ownership and how resources may be used within that
context.  Within the ownership monad it is possible to use the
resources in owned references safely knowing that any violations of
the ownership rules will be caught and prevented.  For that reason
owned references provide an useful building block for constructing
larger abstractions that are concerned with tracking resource ownership.

The key to allowing multiple (potentially mutable) concurrent operations to occur
on a shared resource is to make sure that they will not occur simultaneously.
% TODO explain that this is not a new idea and refer to existing mutex locks and
% so on?
As the chapter introduction alluded, one solution to this problem is to
create a system for shared access to resources that tracks both who owns the
resource in addition to what the resource is.
Using owned references as a building block it is quite easy to build
such a system. Additionally it is possible to do so on top of the existing
Channel interface and the concurrency abstractions which Channels provide in
Haskell.


\section{Owned Channel Operations}

A major idea that owned channels take advantage of is that ownership
of resources - once granted - can be tracked and used in isolation. For that reason
each thread can exist inside its own ownership monad bubble and
remain isolated from the state of resources which exist in other threads.
% TODO add diagram of Ownership Monad "bubbles"
The act of giving up ownership  (on write operations) is enough information to
facilitate the transfer of resource ownership between threads.
% TODO add example to back this up

Beyond keeping track of this inter-thread ownership information - which is
facilitated by the owned channel operations - each thread will be able
to govern its own resources.  This prevents any accidental shared ownership of
a resource from occurring. It also does so without having to resort to using an
additional form of communication between the threads or a resource scheduler and
additional overhead. 

\subsection{Writing to an Owned Channel}

Writing to an owned channel takes the contents of an \texttt{ORef} in
one thread and writes it to the Channel - the shared state between the threads.
From the view-point of the thread that wrote to the channel this operation
consumes the \texttt{ORef} and the thread loses the ability to further use the
\texttt{ORef} in later operations.

This operation is composed from the combination of two
\texttt{ORef} operations, a borrow followed by a drop operation, 
although these \texttt{ORef} operations are hidden from the user of the
\texttt{OChan} library.

\begin{verbatim}
writeOChan :: Typeable a => Chan a -> ORef a -> Own ()
writeOChan ch oref = do
  borrowORef oref (\v -> liftIO $ writeChan ch v)
  dropORef oref
\end{verbatim}

\begin{verbatim}
writeOChan' :: Typeable a => OChan a -> ORef a -> Own ()
writeOChan' ch oref = ch >>= (\x -> writeOChan x oref)
\end{verbatim}

To write an \texttt{ORef} to a Channel, the owned channel operation
needs to use the value that the owned reference refers to.  This means
that before any further operations can occur the \texttt{ORef} must not have any
functions currently borrowing its contents and it must exist within the context
of that ownership monad.
If those conditions are satisfied then the first of the two \texttt{ORef}
operations can occur.

In order to write the resource inside the \texttt{ORef} to a traditional Channel
- inside the owned channel - the function writing the resource to the
Channel needs to borrow the resource.
This might seem odd since it would appear that the borrower function does not
intend to ever return the resource.  This is accurate, the resource that was
written to the channel will not be returned; under the rules for a
borrow this kind of use is actually allowed.
There would not seem to be an issue if it were not for the fact that
the borrower function acts on resources shared between threads.

% Given the nature of concurrent operation between threads - doing
% this step alone with the function to write to a channel - would be considered
% dangerous.

This is still occurring inside the larger owned channel write operation and will
be opaque to the user of the library.

The second \texttt{ORef} operation is to drop the \texttt{ORef} that was just
borrowed. This immediately follows the completion of the borrow operation. The
borrow operation used the underlying resource in order to send it to the channel
and upon completion. As far as the ownership monad for that thread is
concerned the \texttt{ORef} no longer has any functions borrowing the reference
when the previous borrow operation is complete.
\footnote{Since the borrow just performed a dangerous multi-threaded IO operation
  it is not entirely true to say that it does not have any borrowers - the
  subsequent drop operation however makes this irrelevant.}

Because the \texttt{ORef} no longer has any borrowers it is now possible to
drop it from that monad using the \texttt{ORef} drop operation.  This will
update the resource ledger for that monad crucially without touching the
resource itself.
% TODO this may no longer be true.
% Drop operations now affect the IORef - but does this affect multithreaded
% IORef's??
% I don't think so because the borrow is making an immutable copy.
% This is worth testing though.
This prevents any further operations from using the resource
in that thread.

\subsection{Reading from an Owned Channel}

Reading from an owned channel can be thought of as the reverse of
writing to an owned channel.  Rather than take the contents of an
\texttt{ORef} and give away ownership of the resource inside it - by writing the
resource to a channel - we are taking ownership of a resource from the channel
and encapsulating it within a new \texttt{ORef}.

\begin{verbatim}
readOChan :: Typeable a => Chan a -> Own (ORef a)
readOChan ch = do
  v <- liftIO $ readChan ch
  newORef v
\end{verbatim}

\begin{verbatim}
readOChan' :: Typeable a => OChan a -> Own (ORef a)
readOChan' oc = oc >>= readOChan
\end{verbatim}

The first \texttt{ORef} operation inside a read from an owned channel
is to read from the traditional channel inside the owned channel. This
retrieves the resource from the channel and will prevent other threads from
reading it. This latter aspect leverages a previously existing aspect of
Haskell Channels. % TODO cite

The second operation is to place the freshly acquired resource inside a new
\texttt{ORef}.  This \texttt{ORef} will then be returned into the
ownership monad context by the read operation on the
owned channel.  The thread can now have access to the \texttt{ORef}
and the value within it using the provided operations in the
ownership monad.

% TODO add more on Reading

\subsection{Creating an Owned Channel}

Creating an owned channel, comparatively, is a very simple operation.
A traditional channel is created through an \texttt{IO} operation and placed
within the ownership monad.

\begin{verbatim}
newOChan :: OChan a
newOChan = do
  ch <- liftIO newChan
  return ch
\end{verbatim}

It should be noted that there are write and read functions provided
in the \texttt{OChan} library that can operate on normal \texttt{IO} bound
channels.  It is recommended to not use these and instead use write and read
functions that only operate on owned channel to safeguard against
accidentally trying to use the traditional channel write and read functions
with \texttt{liftIO}.

\section{Detecting Race Conditions}

In the original example in the introduction an undectable race condition was
created by passing an IORef across a channel between two threads.
Using \texttt{OChan} and \texttt{ORef} operations it is now possible
to pass an \texttt{IOREf} between two channels and detect a situation
that would result in a race condition before the race condition happens.

This is an example of an operation that will succeed. Here we create an
\texttt{IORef} and place it in an \texttt{ORef}. The parent thread
then gives up ownership of the \texttt{ORef} when it writes it to the
owned channel. The child thread can read the \texttt{ORef} from the
\texttt{OChan} and claim ownership over its contents. The child thread
can mutate the resource in a borrow operation and then write it back to
the channel. 

\begin{verbatim}
mutableOChanTest :: Own ()
mutableOChanTest = do
  ch <- newOChan

  ioref <- liftIO $ do
    r <- newIORef "hello"
    return r

  ref <- newORef ioref

  writeOChan ch ref

  _ <- liftIO $ forkIO $ do
    ex <- startOwn $ do
      oref <- readOChan ch
      borrowORef
        oref
        (\x -> do
            liftIO $ modifyIORef x ((++) " from the child thread")
        )
      writeOChan ch oref
      return ()
    return ()

  oref' <- readOChan ch
  borrowORef
    oref'
    (\x -> do
        liftIO $ do
          contents <- readIORef x
          putStrLn contents
    )
  return ()
\end{verbatim}


% \section{Preventing Deadlock}
% % Describe/Define Deadlock
% TODO

% \subsection{Explicit Resource Ownership Prevents Deadlock}
% % How ownership prevents deadlock
% TODO

% \section{Beyond Threads}

% TODO

% How Ownership could be used for resources between processes using D-Bus and also
% servers in distributed computing.

\chapter{Related Works}

\section{Uniqueness Types}

Idris, which treats Uniqueness Types as a subkind of regular Types, shows
the other way of approaching this and the benefits and trade-offs of doing so.

% By allowing non-unique types to exist and be used along side Unique Types,
% Idris offers a degree of flexibility with it's approach to Uniqueness
% Typing that is not present with ours.
% But idris is using it for something other than concurrency - TODO explain


\chapter{Conclusion}
\section{TODO}

\bibliographystyle{plain}
\bibliography{ownership_monad}{}

% \appendix
% \chapter{Redundancy}

\end{document}
