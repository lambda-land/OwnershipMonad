\documentclass[onehalf,11pt]{beavtex}
\title{The Ownership Monad}
\author{Michael McGirr}
\degree{Master of Science}
\doctype{Thesis}
\department{Electrical Engineering and Computer Science}
\depttype{School}
\depthead{Director}
\major{Computer Science}
\advisor{Eric Walkingshaw}
\submitdate{TODO submit date}
\commencementyear{TODO commencement year}
\abstract{TODO abstract statement.}
\acknowledgements{TODO}

\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{hyperref} % For links

\begin{document}
\maketitle

\mainmatter

\chapter{Introduction}
\section{Introduction}

This paper presents a library for Haskell that implements an \textit{ownership-style}
set of rules for resource-aware programming. This ownership system introduces a
set of rules that govern how, when, and by whom a resource within what is called
an Owned reference (an \textit{ORef} ) can be used. While the restrictions this
implementation imposes may seem to increase the complexity of writing programs,
the resulting guaranties that adhering to these rules facilitates offers
significant improvements in specific areas. % that have historically been troublesome for Haskell.

Adding a way to keep track of resources in a pure language like Haskell may
at the onset seem unnecessary since in a pure language, by definition, % TODO Add citation
the data making up the resources bound to variables are immutable. Because of
this there is inherent changing state.  Haskell's purity allows for referential
transparency where values and variables can be thought of as being
interchangeable in the sense that under any context evaluating an expression will
always lead to the same result.  This is a very desirable property that
Haskell's purity grants and it allows for a greater ability to reason about the
behavior of a program.

Unfortunately even in a pure language like Haskell, this property breaks down in
the context of concurrency.  Concurrency introduces a changing state as separate
threads interleave actions.  Under some circumstances this can make a program
in Haskell look and act as though it were an imperative language.

Concurrent Haskell programs can still fall prey to the same fundamental
problems that other impure languages can, namely deadlock and starvation.
% TODO add citation for shared-state concurrency is still hard section from Real
% World Haskell
This paper will demonstrate what some of these problems look like using
basic concurrency tools available in Haskell such as shared state with
MVars and message passing with channels.
It will then demonstrate and explain the benefits of tracking resource usage
with a set of rules similar to affine types. The contribution that
tracking resources while they are being used and sent between threads
will be shown. % TODO rework this sentence

% --
\section{Additional contributions}

While this library does not do so - by tracking resources with the ownership
system it becomes in theory possible to reason about the memory usage over the
lifetime of a program using the type system of the language. 
% refer to:
%https://groups.google.com/d/msg/idris-lang/NsxReBzk7LQ/0fSPgu-4EgAJ
This method makes it possible to do a form of automatic deterministic destruction
instead of the typical garbage collection approaches.  This paper will show
where in an example program this could occur.

% enforcement of the rules can be done at compile time.

\section{Background}

Approaching resource usage with this style of implementation is not a new
concept.
Restricting all entities to following the rules specified under a affine type
system discipline is applied under the Ownership System in the Rust
programming language. 
% TODO Explain the ownership system in Rust
% Mention improvements this offers Rust

% TODO rework Idris section
Idris, which treats Uniqueness Types as a subkind of regular Types, shows
the other way of approaching this and the benefits and tradeoffs of doing so.
By allowing non-unique types to exist and be used along side Unique Types,
Idris offers a degree of flexibility with it's approach to Uniqueness
Typing that is not present with ours. % But idris is using it for something
% other than concurrency - TODO explain

% TODO refer to this:
% Using the type system to encode and explain what is happening with the underlying
% resources in a general way that can be independently verified and checked greatly
% increases our confidence and ability to know when a resource is finished being used.
% refer to Edwin Brady quote at:
% https://groups.google.com/d/msg/idris-lang/Z28F3MBBtTM/XOnUcrvsBAAJ


\chapter{The Ownership Monad}

The term \textit{Ownership System} is used to describe the system for how
resources are tracked and how they can be used once they are created.
The \textit{Move semantics} describe the outcome from using the operations provided
for the \textit{Ownership System}.

The \textit{Ownership System} and \textit{Move semantics} this library
implements are inspired by the Ownership system in Rust as well as
Uniqueness types from Idris. \cite{rust_book_ownership} \cite{idris_uniqueness_types}
The \textit{Ownership System} described by this paper and implemented by the
accompanying library approximates some of the features from the Rust language
Differences result between the two from the different language paradigms and
the different use cases. Uniqueness types in Idris, ownership in Rust, and
the \textit{Ownership Monad} all use some form of the idea that by tracking
resource use and applying rules to how resources are used - certain properties
can be enforced.

\section{The Ownership System}

Resources are bound to a variable once they are created inside the Ownership
Monad.  These variables are the mechanism to access - or refer - to the
underlying resource.  In the library these are called ORef's -
or \textit{Owned References}.

\subsection{Reference Creation}

An \textit{Owned Reference} is created within the Ownership Monad and bound to a
resource. When the operations inside that monad are complete - the references
will no longer exist and the resources will be marked as free.
The information inside of the resource within the \textit{Owned Reference} can
only be accessed by the provided operations for operating on references within
the \textit{Onwership Monad}.  These operations will verify whether the
ownership rules are being followed.

The newly created reference \textit{owns} the resource it was given
when it was created. Resources that are put into references can only have one
owner at any given time. This reference bound to the newly initialized resource
becomes the sole owner of that resource.

\subsection{Copying a Reference}

The underlying resource owned by a reference may be copied by other references
within the scope of that ownership monad.  When this occurs the new references is
created and is then given ownership over their copy of the resource.  After a
copy operation is performed the two references will each own what are now,
essentially, two separate and different resources.

For those familiar with the terminology from the Rust programming language, the
term \textit{copy} here is not the same as a copy in Rust. Rust makes a special
distinction between making a copy of resources that are fixed in size
\footnote{Rust will also consider an assignment operation to be a copy instead
  of a move if the \textbf{Copy} trait or the \textbf{Clone} trait is
  implemented for that type of resource. \cite{rust_book_traits}
  \cite{rust_docs_clone_trait}}
and making a copy of resources which are more complex and not fixed in size.
For the latter case it is still possible to copy these kinds of resources but these
need to be cloned (using the clone function) otherwise Rust will consider these
values to have been moved. \cite{rust_book_ownership}
With this library there is only one version of a copy and it creates a new
resource identical to the original; there is no distinction given to the kinds
of resources that are being copied.

\subsection{Moving Ownership}

A resource owned by a reference can also be transferred to a new reference or
to an existing reference. After this operation is performed it will no longer
be possible to refer to the underlying resource through the old reference. This
operation removes the old reference from the scope of the ownership monad it
previously existed in and the new reference is now the sole owner of the
resource.

Move operations provide a way for a references to interact with
other references and provide a building block for larger more complex
abstractions that will be discussed later on.

There is a key difference between moving a resource from an existing reference
and copying it to a new one.  Functionally a resource that is copied is cloned
and duplicated; doing this doubles the space and creates a new resource.
A moved resource by comparison doesn't change - instead what is altered is the
record of who owns that resource.  Neither operation, moving and copying,
creates a situation where more than one reference owns a resource.

\subsection{Reading a Resource}

\textit{Reading} a resource is the operation that allows a function to have
access to be able to use the contents of an owned reference.
This is to say that a resource can be used within the confines of the ownership
monad by its owner and a function that will be required to return the resource
to the context of the ownership monad.

This operation is similar to in the Rust language of passing an immutable value to
a function as an immutable borrow. % TODO rework
To give some background on this: depending on the type signature, a function in
Rust will either copy the value it is passed, take ownership of the value, or it
will borrow the value - in which case ownership of the value is automatically
returned when the function has finished execution.\cite{rust_book_ownership}
A function in Rust that takes a borrowed value as an argument is - in a way -
syntactic sugar over that function first taking ownership of the value and then
returning ownership over it as part of the return value.
Instead of having to do these steps explicitly - a value can be passed to a
function as a borrowed value.  When a value is borrowed, the function will take
a reference to that the value from the original owner and eventually the
ownership of the resource will be handed back when the function returns.
The Rust compiler which will track the borrows (with the borrow checker).
% TODO I know this is how it works - but I should cite this to be sure.

Borrows in Rust come in two flavors - we can either lend a resource to many
borrowers if the borrowers never mutate the underlying resource - or we can
lend it to a single borrower that will be able to mutate the
resource.\cite{rust_book_borrowing}
It should be clear why giving multiple variables mutable access to
the same resource could create data races - which is why mutable borrows to
multiple variables (or functions) are not allowed.

This library takes a slightly different approach: a read operation
lends the resource to a function which temporarily borrows the resource
in order to use it. While the resource is being borrowed it is prevented
from being written to. The function remains inside of the context of the
Ownership monad.

Much like the Rust language will not allow for a mutable resource to be lent to
multiple borrowers - neither will the read operation on a ORef.
The ORef will ensure that the resource is not mutated or writen to while is it
lent out to the borrowing function. 
Because each read operation occurs within the context of the ownership monad the
resource usage can be tracked and this property can be ensured.
The reference that owns the resource will track the resource while the 
function executes.

This library does allow multiple functions to simultaneously perform
\textit{read} operations on an existing ORef.
This is equivalent to a variable being borrowed by more than one immutable
borrowers in Rust.  In this library the read operation can only read the value
and will not allow the resource to be mutated.

The read operation also ensures that the original ORef is not able to go away
before the function borrowing it is complete - this will make sure that the
function is not referring to an ORef that no longer exists.  The ORef that is
being borrowed by the function is not able to be moved (or otherwise dropped)
before the function that the resource has been lent to is complete.

\subsection{Writing to a Resource}

A resource can be changed by its owner as long as it does not have any borrowers.
The value within the resource can be updated and changed through the reference
that owns the resource. This operation can be performed safely because the usage
of the underlying resource is tracked by the ownership monad.

% The key to allowing multiple (potential mutable) operations to occur on a
% resource is to make sure that they will not occur simultaneously.


\subsection{Differences from Rust}

% Writing to a Borrowed Resource.
This library does not allow a function borrowing a resource to be able to
write to or mutate the resource in the original ORef.  In Rust this would be
equivalent to having a single mutable borrower. The read operation in this
library only permits the function borrowing that resource to read from the
original ORef and not write to it.
% TODO Mention the Idris approach of borrows

% If this were to be allowed we would need to know
% whether or not any other variables were borrowing the resource
% since we do allow for multiple immutable reads/borrows.
%
% In order to allow one borrower to be able to mutate with resource we would
% need to be able to say that it was the only borrower. At the moment we
% do not track how many borrowers a resource has - only that during a read
% operation that is has one or more.


\section{Move Semantics}

\subsection{Behavior}

With the Ownership system enforcing the rules dictating how a resource can be
used

\section{ORef's}
ORef's section

% \chapter{Conclusion}
% TODO
% \section{}


\bibliographystyle{plain}
\bibliography{ownership_monad}{}

% \appendix
% \chapter{Redundancy}

\end{document}
