\documentclass[onehalf,11pt]{beavtex}
\title{The Ownership Monad}
\author{Michael McGirr}
\degree{Master of Science}
\doctype{Thesis}
\department{Electrical Engineering and Computer Science}
\depttype{School}
\depthead{Director}
\major{Computer Science}
\advisor{Eric Walkingshaw}
\submitdate{TODO submit date}
\commencementyear{TODO commencement year}
\abstract{TODO abstract statement.}
\acknowledgements{TODO}

\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{hyperref} % For links

\begin{document}
\maketitle

\mainmatter

\chapter{Introduction}

This project report presents a library for Haskell that implements an
\textit{ownership system} for resource aware programming. This ownership system
introduces a set of rules that govern how, when, and by whom a resource within
what is called an \textit{Owned Reference} (an \texttt{ORef}) can be used.

While the restrictions this implementation imposes may seem to increase the
complexity of writing programs, the resulting guaranties over resource usage
that adhering to these rules facilitates offer improvements in specific areas.
Furthermore applying this system provides an example for how monadic based
systems with fewer restrictions than linear types can offer many of the same
abilities to reason about resource usage without becoming as unwieldy to use
as some linear type systems. 

Adding a way to keep track of resources in a pure language like Haskell may
at the onset seem unnecessary since in a pure language, by definition, % TODO Add citation
the data making up the resources bound to variables is immutable. Because of
this there is no inherent state.  Haskell's purity therefore allows for referential
transparency where values and variables can be thought of as being
interchangeable in the sense that under any context evaluating an expression will
always lead to the same result. % TODO change this sentence
Referential transparency is a very desirable property which allows for a greater
ability to reason about the behavior and correctness of a program.

Unfortunately even in a pure language like Haskell, this property breaks down in
the context of concurrency.  In order to allow separate threads to communicate
the basic mechanisms provided by Concurrent Haskell introduce mutable state.
Adding mutable state and sharing it between threads explicitly introduces
side-effects into otherwise pure and referentially transparent computations.
Under these circumstances, Haskell's usual approach of segregating side-effects
into monadic computations does not resolve every issue that can exist with
shared-state concurrency.

Linear types are often suggested as a possible solution to limit the issues that
result from mutable state \cite{Wadler90lineartypes} and concurrency
\cite{caires2010session}.  Language level support for linear types has been
proposed for the Glasgow Haskell Compiler. \cite{LinearTypesGHC}
% This would add plain linear types, directly inspired from linear logic.
Ways to add Linear types to Haskell without language level support have also
been demonstrated using embedded domain specific languages within a monadic
context. \cite{Paykin:2017:LM:3122955.3122965}

The issue that these solutions often have to contend with is that linear types
can become cumbersome to work with.
Other less restrictive forms logic have been used in type systems for similar
resource tracking.
Affine type systems weaken the restrictions imposed by linear type systems.
Instead of requiring every variable to be used exactly once - as is the case
with linear types - every variable must be used at most once.
The language level Ownership typing in Rust has been directly inspired by Affine
type systems.
% TODO Add more here

\section{Contributions}

This project draws from the use of affine types in Rust for
ownership typing to define a similar method for tracking resources with Haskell.
This is combined with the approach of defining embedded languages in monadic
programming to allow for ownership typing without language level support for
affine types in Haskell. This project will demonstrate that the existing model
for embedded languages in monadic programming extends to affine types.

Concurrent Haskell programs can still fall prey to some of the same fundamental
problems that other impure languages can, namely deadlock and starvation.
% TODO add citation for shared-state concurrency from Real World Haskell
% In Concurrent Haskell the most basic way to allow separate threads to
% communicate is with a shared mutable variable. 
This project report will demonstrate a motivation for adding the kind of
resource tracking that ownership typing provides by looking at what some of
these problems look like and how resource tracking acts to mitigate these
problems.  This will use the basic concurrency tools available in Haskell
such as shared state with MVar's and message passing with Channels.
It will then demonstrate and explain the benefits of tracking resource usage
with a set of rules similar to affine types.


% While this library does not do so - by tracking resources with the ownership
% system it becomes in theory possible to reason about the memory usage over the
% lifetime of a program using the type system of the language. 
% refer to:
%https://groups.google.com/d/msg/idris-lang/NsxReBzk7LQ/0fSPgu-4EgAJ
% This method makes it possible to do a form of automatic deterministic destruction
% instead of the typical garbage collection approaches.  This paper will show
% where in an example program this could occur.

% TODO refer to this:
% Using the type system to encode and explain what is happening with the underlying
% resources in a general way that can be independently verified and checked greatly
% increases our confidence and ability to know when a resource is finished being used.
% refer to Edwin Brady quote at:
% https://groups.google.com/d/msg/idris-lang/Z28F3MBBtTM/XOnUcrvsBAAJ


\chapter{The Ownership Monad}

The term \textit{Ownership System} is used to describe the system for how
resources are tracked and how they can be used once they are created. This
system operates within the context of the ownership monad.
\textit{Move Semantics} describe the outcome from using the operations provided
for the ownership system.

The ownership system and move semantics this library implements are inspired by
ownership typing in Rust as well as Uniqueness Types
from Idris.\cite{rust_book_ownership} \cite{idris_uniqueness_types}
% Restricting all entities to following the rules specified under an
% affine typing system discipline is applied under the ownership typing system in
% the Rust programming language. % TODO rework
The ownership system described by this paper approximates some of the
features from ownership typing in the Rust language - differences between
the two result from the different language paradigms and the different use cases.

Uniqueness types in Idris, ownership typing in Rust, and the ownership system
make use of the idea that by tracking resource use and applying rules to how
resources are used - certain properties can be enforced.
% TODO briefly what these are here

The type of the ownership monad:

% Ownership Monad with IO in the transformers stack

\begin{verbatim}
type Own a = StateT (ID,Store) (EitherT String IO) a
\end{verbatim}

State is represented using the \texttt{StateT} monad transformer.
The ownership monad needs to track the state of ownership system operations
that occur within its context but it does not need to be aware of the
operations occurring in other ownership monads. This latter aspect will become
important when discussing Owned Channels between separate threads later on.

% TODO explain what's in the entry datatype

\section{The Ownership System}

Resources are bound to a variable once they are created inside the ownership
monad.  These variables are the mechanism to access - or refer - to the
underlying resource.  In the library these variables are called ORef's -
or \textit{Owned References}.

\subsection{Reference Creation}

The \texttt{newORef} function creates a new owned reference
within the ownership monad and places the value provided to the function
inside the reference. 

\begin{verbatim}
newORef :: Typeable a => a -> Own (ORef a)
newORef a = do
    (new,store) <- get
    thrId <- liftIO $ myThreadId
    let entry = (Entry True True 0 thrId a)
    put (new + 1, insert new entry store)
    return (ORef new)
\end{verbatim}

The current state of the monad is needed in order
to produce the new state which will include the new owned reference.
The new owned reference is a mapping of an ID and the entry which contains
the value and state of the owned reference.
Performing \texttt{get} will return the ID to use next as well as the current
mapping of owned reference ID's and their entries.

In order to prevent the child threads from using the owned references that
were potentially inherited through the namespacing scope of their parent
threads - the thread ID of the thread that created the owned reference must
be stored.
This is set when the owned reference is initially created and requires
an \texttt{IO} operation to get the current thread ID of the thread
creating the new \texttt{ORef}.

The entry that will be inserted into the new mapping will have its read and
write flags initially set to true and its borrower count initialized to zero.
It will also consist of the thread ID of its creator and the value to store.


When the operations inside that monad are complete - the references
will no longer exist and the resources will be marked as free.
% TODO this is actually quite significant and worth explaining more because it
% allows us to determine when a resource no longer needs to exist.
% (can be automatically destroy and freed)
% Explain that ORef's are dropped once the monad is finished evaluating - and we
% know they can be dropped then.
The information inside of the resource which is bound to the owned reference can
only be accessed by the provided operations for references within the ownership
monad.

These operations which act on owned references will verify whether the ownership
rules are being followed and prevent violations.

Resources that are put into references can only have one owner at any given
time. The reference bound to the newly initialized resource becomes the sole
owner of that resource. 
The type of an \texttt{ORef} is a thin wrapper around a way to tag and identify
resources.

\begin{verbatim}
data ORef a = ORef ID
\end{verbatim}

An \texttt{ORef} is a parameterized abstract data type. The polymorphic
\texttt{a} allows any type to be stored in an \texttt{ORef}.
This datatype serves to provide a handle on each resource for the \texttt{Own}
monad to use as it enforces ownership typing rules and tracks each resource.

\subsection{Copying a Reference}

The underlying resource owned by a reference may be copied by other references
within the scope of that ownership monad.  When this occurs the new references is
created and is then given ownership over their copy of the resource.  After a
copy operation is performed the two references will each own what are now,
essentially, two separate and different resources.

\begin{verbatim}
copyORef :: ORef a -> Own (ORef a)
\end{verbatim}

For those familiar with the terminology from the Rust programming language, the
term \textit{copy} here is not the same as a copy in Rust. Rust makes a special
distinction between making a copy of resources that are fixed in size
\footnote{Rust will also consider an assignment operation to be a copy instead
  of a move if the \textbf{Copy} trait or the \textbf{Clone} trait is
  implemented for that type of resource. \cite{rust_book_traits}
  \cite{rust_docs_clone_trait}}
and making a copy of resources which are more complex and not fixed in size.
For the latter case it is still possible to copy these kinds of resources but these
need to be cloned (using the clone function) otherwise Rust will consider these
values to have been moved. \cite{rust_book_ownership}
With this library there is only one version of a copy and it creates a new
resource identical to the original; there is no distinction given to the kinds
of resources that are being copied.

\subsection{Moving Ownership}

A resource owned by a reference can also be transferred to a new reference or
to an existing reference. After this operation is performed it will no longer
be possible to refer to the underlying resource through the old reference. This
operation removes the old reference from the scope of the ownership monad it
previously existed in and the new reference is now the sole owner of the
resource.

The library function for moving resources from one \texttt{ORef} to another has
the following type:

\begin{verbatim}
moveORef :: ORef a -> Own (ORef a)
\end{verbatim}

Move operations provide a way for a references to interact with
other references and provide a building block for larger more complex
abstractions that will be discussed later on.

There is a key difference between moving a resource from an existing reference
and copying it to a new one.  Functionally a resource that is copied is cloned
and duplicated; doing this doubles the space and creates a new resource.
A moved resource by comparison doesn't change - instead what is altered is the
record of who owns that resource.  Neither operation, moving and copying,
creates a situation where more than one reference owns a resource.

\subsection{Immutably Borrowing a Resource}

Borrowing a resource is the operation that allows a function to have
access to be able to use the contents of an owned reference.
A resource can be used within the confines of the ownership monad by its owner
and a function that will be required to return the resource to the context of
the ownership monad.

This operation is similar to passing a value to a function as an immutable
borrow in the Rust language.  To give some background on what this means:
depending on the type signature a function in Rust will either copy the value
it is passed, take ownership of the value, or it will borrow the value - in
which case ownership of the value is automatically returned when the function
has finished execution.\cite{rust_book_ownership}
A function in Rust that takes a borrowed value as an argument is - in a way -
syntactic sugar over that function first taking ownership of the value and then
returning ownership over the value by placing it within the expression that is
returned.
Instead of having to do these steps explicitly - a value can be passed to a
function as a borrowed value.  When a value is borrowed, the function will take
a reference to that the value from the original owner and eventually the
ownership of the resource will be handed back when the function returns.
The Rust compiler which will track the borrows (with the borrow checker).
% TODO add citation

Borrows in Rust come in two flavors - we can either lend a resource to many
borrowers as long as the borrowers never mutate the underlying resource - or we
can lend it to a single borrower that will be able to mutate the
resource.\cite{rust_book_borrowing}
It should be clear why giving multiple variables mutable access to
the same resource could create data races - which is why mutable borrows to
multiple variables (or functions) are not allowed.

This library takes a slightly different approach: instead of letting variables
borrow a resource, a borrow operation instead lends the resource to a function
which temporarily borrows the resource in order to use it.

While the resource is being borrowed it is prevented from being written to.
The function that borrows the resource is of type \texttt{(a -> Own b)}. The
resource being consumed in the function remains inside of the context of the
ownership monad while the function executes.

\begin{verbatim}
borrowORef :: Typeable a => ORef a -> (a -> Own b) -> Own b
\end{verbatim}

Much like the Rust language will not allow for a mutable resource to be lent to
multiple borrowers - neither will the borrow operation on a \texttt{ORef}.
The \texttt{ORef} will ensure that the resource is not mutated or written to while is it
lent out to the borrowing function. 
Because each borrow operation occurs within the context of the ownership monad
the resource usage can be tracked and this property can be ensured. The
reference that owns the resource will track the resource while the function
executes.

The borrow operation also ensures that the original \texttt{ORef} is not able to go away
before the function borrowing it is complete - this will make sure that the
function is not referring to an \texttt{ORef} that no longer exists.  The \texttt{ORef} that is
being borrowed by the function is not able to be moved (or otherwise dropped)
before the function that the resource has been lent to is complete. This is
enforced by the move and drop which individually check that
a \texttt{ORef} does not have any borrowers before they operate on the \texttt{ORef}.

This library also allows multiple functions to simultaneously perform
\textit{borrow} operations on an existing \texttt{ORef}. This is equivalent to a variable
being borrowed by more than one immutable borrower in Rust. To do this a
borrower count is maintained by each \texttt{ORef} and the writable flag is not
reset until this count is zero.

In this library the borrow operation can only read the value and will not allow
the resource to be mutated by the function.  In order to be able to borrow and
mutate the reference a different operation is required.

\subsection{Mutably Borrowing a Resource}

This library also allows a function borrowing a resource to be able to
write to (or mutate) the resource in the original \texttt{ORef}.  In Rust this would be
equivalent to having a single mutable borrower.  The \textit{mutable borrow}
operation in this library permits the function borrowing that resource to read
and set the value in the original \texttt{ORef}.

\begin{verbatim}
mutableBorrowORef :: Typeable a => ORef a -> (a -> Own a) -> Own ()
\end{verbatim}

To allow a mutable borrow it is necessary to know if other functions are
borrowing the resource.  Each \texttt{ORef} tracks if it has borrowers by keeping a
ledger indicating if it is able to be read from or written to and how many
living borrowers it has.  When a resource has one or more immutable borrowers it
is no longer able to be written to - but it can still be read from.
The reason why \texttt{ORef}'s have two flags - one for read and one for write - is that
if a resource can be both read from and written to then we know it doesn't have
any borrowers; if it cannot be read from or written to we know it was either
dropped or it currently already has a mutable borrower.
In order to allow one borrower to be able to mutate the resource it is required
that it is the only borrower of the resource at that time. % TODO rework
A mutable borrow is prevented from happening is the \texttt{ORef} is not writable.

% TODO Mention the Idris approach of borrows

\subsection{Writing to a Resource}

A resource can be changed by its owner as long as it does not have any borrowers.
The value within the resource can be updated and changed through the reference
that owns the resource. This operation can be performed safely because the usage
of the underlying resource is tracked by the ownership monad.

\begin{verbatim}
writeORef :: Typeable a => ORef a -> a -> Own ()
\end{verbatim}

The existing resource in side the ORef is over written by the new value.

\subsection{Dropping an Owned Reference}

The \textit{drop} operation will explicitely remove an owned reference from the
ownership monad it previously existed in.
This will destroy the resource from the point of view of that ownership context.

\begin{verbatim}
dropORef :: ORef a -> Own ()
\end{verbatim}

Any further operations will be prevented from occurring using the dropped
reference. In order to be dropped: a resource must not have any borrowers,
it must exist in that context,
and it must be readable and writable.
Otherwise the drop operation will not be permitted.

\section{Move Semantics}

\subsection{Behavior}

TODO

% With the Ownership system enforcing the rules dictating how a resource can be
% used

\section{ORef's}

TODO ORef's example section


\chapter{Owned Channels}

\section{Introduction}

\textit{Owned Channels} expand on the concept of using channels between threads
to write to and read from a shared location.   As with traditional Channels,
this location can be used by concurrent threads in order to share resources and
to communicate.

% Shared state brings with it all the dangers associated with it. REWORK
% As our example shows - issues can crop up when resources are shared between
% threads. % TODO add example

Owned channels operate using the idea that instead of sending just the
resource across a channel - send the ownership of the resource as well.
The key idea behind owned channels is for the thread sending a
resource across a channel to relinquish ownership over the resource.
A thread reading a resource from the channel automatically gains ownership over
the resource it consumes from the channel.

Once a thread has sent a resource over the channel - all operations in the thread
will need to be prevented from using that resource.
If the thread later needed to use the resource again it would have to read the
resource from a channel and gain back ownership over the resource.

Traditionally the variable that was written to a channel would still exist in the
scope of the code in the thread that originally wrote the resource to a channel.
As a result it would be perfectly legal to write code that later referred to the
resource through an existing variable binding in the original thread.
% TODO refer to a code example for this
In order to enforce which thread owns which resource, there would need to be
some way to track not just what a resource is but also what variable (and what
thread) owns a resource.

\subsection{Using Owned References to Construct Owned Channels}

As discussed earlier, owned references provide a fundamental set of
rules generalizing resource ownership and how resources may be used within that
context.  Within the ownership monad it is possible to use the
resources in owned references safely knowing that any violations of
the ownership rules will be caught and prevented.  For that reason
owned references provide an useful building block for constructing
larger abstractions that are concerned with tracking resource ownership.

The key to allowing multiple (potentially mutable) concurrent operations to occur
on a shared resource is to make sure that they will not occur simultaneously.
% TODO explain that this is not a new idea and refer to existing mutex locks and
% so on?
As the chapter introduction alluded - one solution to this problem is to
create a system for shared access to resources that tracks both who owns the
resource in addition to what the resource is.
Using owned references as a building block it is quite easy to build
such a system. Additionally it is possible to do so on top of the existing
Channel interface and the concurrency abstractions which Channels provide in
Haskell.


\section{Owned Channel Operations}

A major idea that owned channels take advantage of is that ownership
of resources - once granted - can be tracked and used in isolation. For that reason
each thread can exist inside its own ownership monad bubble and
remain isolated from the state of resources which exist in other threads.
% TODO add diagram of Ownership Monad "bubbles"
The act of giving up ownership - on write operations - is enough information to
facilitate the transfer of resource ownership between threads.
% TODO add example to back this up
Beyond keeping track of this inter-thread ownership information - which is
facilitated by the owned channel operations - each thread will be able
to govern its own resources.  This prevents any accidental shared ownership of
a resource from occurring and does so without having to resort to using an
additional form of communication between the threads or a resource scheduler.
This saves adding any additional overhead.



\subsection{Writing to an Owned Channel}

Writing to an owned channel takes the contents of an \texttt{ORef} in
one thread and writes it to the Channel - the shared state between the threads.
From the view-point of the thread that wrote to the channel - this operation
consumes the \texttt{ORef} and the thread loses the ability to further use the
\texttt{ORef} in later operations.

This operation can conceptually be thought of as the combination of two
\texttt{ORef} operations - an borrow followed by a drop operation -
% TODO should we distinguish what kind of borrow?
although these \texttt{ORef} operations are hidden from the user of the
\texttt{OChan} library.

To write an \texttt{ORef} to a Channel, the owned channel operation
needs to use the value that the owned reference refers to.  This means
that before any further operations can occur the \texttt{ORef} must not have any
borrowers and it must exist within the context of that ownership monad.
If those conditions are satisfied then the first of the two \texttt{ORef}
operations can occur.

In order to write the resource inside the \texttt{ORef} to a traditional Channel
- inside the owned channel - the function writing the resource to the
Channel needs to borrow the resource.
This might seem odd since it would appear that the borrower function does not
intend to ever return the resource.  This is accurate, the resource that was
written to the channel will not be returned; under the rules for an immutable
borrow this kind of use is actually allowed.  If it were not for the fact that
the borrower function acts on resources shared between threads there would not be
any issue.  Given the nature of concurrent operation between threads - doing
this step alone with the function to write to a channel - would be considered
dangerous.  It is also crucial to remember that this is still occurring inside
the larger owned channel write operation and will be opaque to the user
of the library.

The second \texttt{ORef} operation is to drop the \texttt{ORef} that was just
borrowed. This immediately follows the completion of the borrow operation. The
borrow operation used the underlying resource in order to send it to the channel
and upon completion - as far as the ownership monad for that thread is
concerned - the \texttt{ORef} no longer has any borrowers.
\footnote{Since the borrow just performed a dangerous multi-threaded IO operation
  it is not entirely true to say that it does not have any borrowers - the
  subsequent drop operation however makes this irrelevant.}
Because the \texttt{ORef} no longer has any borrowers it is now possible to
drop it from that monad using the \texttt{ORef} drop operation.  This will
update the resource ledger for that monad - crucially without touching the
resource itself - and prevents any further operations from using that resource
in that thread.

\subsection{Reading from an Owned Channel}

Reading from an owned channel can be thought of as the reverse of
writing to an owned channel.  Rather than take the contents of an
\texttt{ORef} and give away ownership of the resource inside it - by writing the
resource to a channel - we are taking ownership of a resource from the channel
and encapsulating it within a new \texttt{ORef}.

The first \texttt{ORef} operation inside a read from an owned channel
is to read from the traditional channel inside the owned channel. This
retrieves the resource from the channel and will prevent other threads from
reading it. This latter aspect leverages a previously existing aspect of
Haskell Channels. % TODO cite

The second operation is to place the freshly acquired resource inside a new
\texttt{ORef}.  This \texttt{ORef} will then be returned into the
owership monad context by the read operation on the
owned channel.  The thread can now have access to the \texttt{ORef}
and the value within it using the provided operations in the
ownership monad.

% TODO add more on Reading

\subsection{Creating an Owned Channel}

Creating an owned channel, comparatively, is a very simple operation.
A traditional channel is created through an \texttt{IO} operation and placed
within the ownership monad.

It should be noted that there are write and read functions provided
in the \texttt{OChan} library that can operate on normal \texttt{IO} bound
channels.  It is recommended to not use these and instead use write and read
functions that only operate on owned channel to safeguard against
accidentally trying to use the traditional channel write and read functions
with \texttt{liftIO}.

\section{Preventing Deadlock}
% Describe/Define Deadlock
TODO

\subsection{Explicit Resource Ownership Prevents Deadlock}
% How ownership prevents deadlock
TODO

\section{Beyond Threads}

TODO

How Ownership could be used for resources between processes using D-Bus and also
servers in distributed computing.

\chapter{Related Works}

\section{Uniqueness Types}

Idris, which treats Uniqueness Types as a subkind of regular Types, shows
the other way of approaching this and the benefits and trade-offs of doing so.

% By allowing non-unique types to exist and be used along side Unique Types,
% Idris offers a degree of flexibility with it's approach to Uniqueness
% Typing that is not present with ours.
% But idris is using it for something other than concurrency - TODO explain


\chapter{Conclusion}
\section{TODO}

\bibliographystyle{plain}
\bibliography{ownership_monad}{}

% \appendix
% \chapter{Redundancy}

\end{document}
